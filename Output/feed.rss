<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>overdesigned blog</title><description>A blog by Adam Overholtzer</description><link>https://blog.overdesigned.net</link><language>en</language><lastBuildDate>Wed, 29 Sep 2021 15:43:39 -0700</lastBuildDate><pubDate>Wed, 29 Sep 2021 15:43:39 -0700</pubDate><ttl>250</ttl><atom:link href="https://blog.overdesigned.net/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2021-09-27-swiftui-animation-tricks</guid><title>SwiftUI Animation Lessons From Building “Time’s Up! Timer”</title><description>Here are a few of the SwiftUI animation tips and tricks I’ve learned while building my kid-friendly timer app Time’s Up! Timer.</description><link>https://blog.overdesigned.net/posts/2021-09-27-swiftui-animation-tricks</link><pubDate>Mon, 27 Sep 2021 09:41:00 -0700</pubDate><content:encoded><![CDATA[<figure><img src="https://blog.overdesigned.net/images/times-up-promo.jpg" alt="Screenshot of a Time’s Up! Timer" /></figure><h1>SwiftUI Animation Lessons From Building “Time’s Up! Timer”</h1><p>I recently launched <strong><a href="https://overdesigned.net/timesup/">Time’s Up! Timer</a></strong>, a kid-friendly timer app for iOS, macOS, and tvOS. It’s a SwiftUI app that makes heavy use of animations, so I thought I’d share a few of the SwiftUI animation tips and tricks I’ve learned building it.</p><h2>Use <code>animation(_:value:)</code> instead of <code>.animation(_:)</code></h2><p>Let’s start with the simplest lesson: always use <code>animation(_:value:)</code> for implicit animations. Unlike the simpler <code>.animation(_:)</code> modifier, this also requires an <code>Equatable</code> value parameter and the animation will <em>only</em> be applied when that value changes. Without this, the animation may run when other properties change or during transitions.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-1.gif" alt="Animated GIF of a springy clock hand." /></figure><p>Here’s an excerpt from the code for my timer view, which draws a clock face and a hand. The hand moves with a bouncy spring animation when its <code>angle</code> changes, thanks to <code>animation(.interactiveSpring(), value: angle)</code>.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TimerClockfaceView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Angle</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            makeFace()
        
            makeHand()
                .rotationEffect(angle)
                .animation(.interactiveSpring(), value: angle)
        }
    }
}
</code></pre><p>The value-less version of <code>.animation(_:)</code> is deprecated as of iOS 15 / macOS 12, so I guess Apple agrees: always use <code>animation(_:value:)</code>.</p><h2>Always test device rotation</h2><p>Speaking of unwanted animation: SwiftUI views will animate to their new sizes when you rotate your iPhone or iPad, and this may produce some undesirable results. I recommend testing device rotation in the simulator with <strong>Debug &rarr; Slow Animations</strong> enabled so you can see exactly what’s happening and fix it.</p><h2>Respect your user’s Reduce Motion setting</h2><p>iOS has a Reduce Motion accessibility setting, which disables or simplifies most animations: <strong>Settings &rarr; Accessibility &rarr; Motion &rarr; Reduce Motion.</strong> It’s important for third-party apps to respect this setting too, and with SwiftUI it’s incredibly easy.</p><p>We first read the user’s preference using the <code>.accessibilityReduceMotion</code> environment value, then use a ternary operator in our <code>animation</code> modifier:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TimerClockfaceView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Angle</span>
    @<span class="hljs-type">Environment</span>(\.accessibilityReduceMotion) <span class="hljs-keyword">var</span> reduceMotion
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            makeFace()
            
            makeHand()
                .rotationEffect(angle)
                .animation(reduceMotion ? .<span class="hljs-keyword">none</span> : .interactiveSpring(),
                           value: angle)
        }
    }
}
</code></pre><h2>Use <code>withTransaction</code> to override implicit animations</h2><p>Here’s a snippet of code from my main view, which shows the timer, the remaining time as <code>Text</code>, and a <strong>Reset</strong> button that will reset the timer with a nice slow <code>.default</code> animation.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">Text</span>(timer.remainingTimeString)
                .font(.title)
            <span class="hljs-type">TimerClockfaceView</span>()
                .aspectRatio(<span class="hljs-number">1</span>, contentMode: .fit)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Reset"</span>) {
                withAnimation(.<span class="hljs-keyword">default</span>) {
                    timer.reset()
                }
            }
        }
    }
}
</code></pre><p>And here’s a capture of what happens when I tap <strong>Reset</strong>.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-2.gif"/></figure><p>It’t not working — the implicit spring animation on the clock hand hand is overriding the explicit <code>withAnimation</code> in our Reset function. How can we <em>override</em> the spring animation?</p><p>The solution is <code>withTransaction</code>, which is similar to <code>withAnimation</code> except it takes a <code>Transaction</code> object. A <code>Transaction</code> is basically an <em>animation context</em>, if you’ve worked with those in UIKit or elsewhere.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        ...
        <span class="hljs-type">Button</span>(<span class="hljs-string">"Reset"</span>) {
            <span class="hljs-keyword">var</span> transaction = <span class="hljs-type">Transaction</span>(animation: .<span class="hljs-keyword">default</span>)
            transaction.disablesAnimations = <span class="hljs-literal">true</span>
            withTransaction(transaction) {
                timer.reset()
            }
        }
    }
}
</code></pre><p>First we create a <code>Transaction</code> with a <code>.default</code> animation. Then we set the Transaction’s <code>disablesAnimations</code> property to true, which tells it to disable all implicit animations on the affected views, e.g. our hand animation. Finally, we call <code>withTransaction(_:_:)</code> like we would <code>withAnimation(_:_:)</code>, providing our transaction and a closure to execute.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-3.gif"/></figure><p>Looks good! (Actually <code>Animation.default</code> is pretty lame and I don’t use it in my app, but you get the idea!)</p><h2>Use <code>transaction(_:)</code> to override explicit animations</h2><p>Now if you look closely at that last animation, you may notice something you wouldn’t expect: when we tap <strong>Reset</strong>, the time <code>Text</code> view changes size and that change is animated.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-4.gif"/></figure><p>Yuck. Let’s disable that animation using <code>transaction(_:)</code>, which is a View Modifier that lets us change or replace the <code>Transaction</code> being applied to the view and its subviews. In this case, we want no animation for the <code>Text</code> so we set <code>transaction.animation</code> to <code>.none</code>.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    	<span class="hljs-type">Text</span>(timer.remainingTimeString)
    	    .transaction { transaction <span class="hljs-keyword">in</span>
    	        transaction.animation = .<span class="hljs-keyword">none</span>
    	    }
    	...
    }
}
</code></pre><p>Here’s the final result: the hand animates smoothly while the time snaps to its new value immediately.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-5.gif"/></figure><p>One word of warning from the <a href="https://developer.apple.com/documentation/SwiftUI/Form/transaction(_:">documentation</a>):</p><blockquote><p>Use this modifier on leaf views such as Image or Button rather than container views such as VStack or HStack. The transformation applies to all child views within this view; calling transaction(_:) on a container view can lead to unbounded scope of execution depending on the depth of the view hierarchy.</p></blockquote><h2>For animation-heavy Mac apps, consider Catalyst</h2><p>We shouldn’t need to use it, and there are some <em>serious</em> downsides — e.g., <code>.toolbar</code> won’t give you Mac toolbars, <code>.commands</code> don’t work at all — but for whatever reason, SwiftUI animations run much, <em>much</em> better in Catalyst.</p><h2>Learn more</h2><p>For an in-depth look animation in SwiftUI, including <code>GeometryEffect</code> and the fancy new <code>TimelineView</code>, I highly recommend SwiftUI Lab’s <strike>three</strike><em>five</em> part series:</p><ol><li><a href="https://swiftui-lab.com/swiftui-animations-part1/">Advanced SwiftUI Animations – Part 1: Paths</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part2/">Advanced SwiftUI Animations – Part 2: GeometryEffect</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part3/">Advanced SwiftUI Animations – Part 3: AnimatableModifier</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part4/">Advanced SwiftUI Animations — Part 4: TimelineView</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/">Advanced SwiftUI Animations – Part 5: Canvas</a></li></ol><p>If these lessons have been helpful, please check out <strong><a href="https://overdesigned.net/timesup/">Time’s Up! Timer</a></strong> and leave a nice review!</p><p>And if you have further questions/comments/corrections, please reach out to <a href="https://twitter.com/aoverholtzer">@aoverholtzer on Twitter</a>. Thanks for reading!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2021-08-26-catalyst-status-menu</guid><title>Standalone Status Menu in a Mac Catalyst App</title><description>How to create a standalone “status menu” app and embed it in your Mac Catalyst app.</description><link>https://blog.overdesigned.net/posts/2021-08-26-catalyst-status-menu</link><pubDate>Thu, 26 Aug 2021 09:41:00 -0700</pubDate><content:encoded><![CDATA[<h1>Standalone Status Menu in a Mac Catalyst App</h1><figure><img src="https://blog.overdesigned.net/images/cheatsheet-menu.jpg" srcset="/images/cheatsheet-menu.jpg 2x" alt="Screenshot of Cheatsheet’s status menu" /></figure><p>I make a somewhat successful app called <a href="https://itunes.apple.com/app/id1468213484">Cheatsheet</a>, which is available for iOS, watchOS, and — thanks to Catalyst — macOS. Cheatsheet makes it easy to get to your notes from anywhere, which means widgets and custom keyboards on iOS and complications on watchOS. On macOS, Cheatsheet has a <em>status menu app</em>.</p><p>Look up at the righthand side of a Mac’s menu bar and you’ll see a row of icons called <strong>status menus</strong>. Several status menus are provided by macOS, such as the Wi-Fi and Volume controls. Third-party apps can also create status menus to provide easy, always-available access to app features.</p><p>In this post, I will walk you through creating a <strong>status menu app</strong> — a small Mac app that runs separately from its parent app — and embedding it in a <strong>Mac Catalyst app</strong>. The parent app will have a checkbox that shows or hides the status menu, and clicking the status menu icon will show a popover.</p><figure><img src="https://blog.overdesigned.net/images/status-menu-example.jpg" alt="Screenshot of my sample app and status menu" /></figure><h2>Create the Status Menu App</h2><p>Let’s start with the fun part: building the status menu app. We’ll build this new app with <strong>AppKit and SwiftUI</strong>, not iOS or Catalyst. Don’t fret if you’re new to AppKit — this post has all the AppKit code you’ll need, and then you can build the rest of your interface with SwiftUI.</p><p>To begin, select your project and add a new <strong>macOS App</strong> target.</p><figure><img src="https://blog.overdesigned.net/images/menu-mac-app.png" srcset="/images/menu-mac-app.png 2x" alt="Screenshot of a Xcode’s Add Target window" /></figure><p>Then in the “Choose options for your new target” screen, select <strong>Interface: SwiftUI</strong> and <strong>Life Cycle: AppKit App Delegate</strong>. We need the AppDelegate so we can create a windowless app, which is <em>technically</em> possible with the SwiftUI life cycle but it’s a bit of a <a href="https://github.com/zaferarican/menubarpopoverswiftui2">hack</a> and still requires an app delegate.</p><figure><img src="https://blog.overdesigned.net/images/menu-life-cycle.png" srcset="/images/menu-life-cycle.png 2x" alt="Screenshot of a Xcode’s Choose options for your new target window" /></figure><p>Enter a <strong>Product Name</strong> and click <strong>Finish</strong>.</p><p>Now select your new target and switch to its <strong>Info</strong> tab. Add a new property: <strong>Application is agent (UIElement)</strong>. Set its value to <strong>YES</strong>. This cryptically-named property tells macOS to run your app as an “agent”, which means it won’t appear in the Dock or the Force Quit window.</p><figure><img src="https://blog.overdesigned.net/images/menu-uielement.png" srcset="/images/menu-uielement.png 2x" alt="Screenshot of the Info tab of our new target in Xcode" /></figure><p>With that out of the way, we’re ready to code! In the project navigator, open your new target’s <strong>AppDelegate.swift</strong> and look for <code>applicationDidFinishLaunching</code>. It will contain a bunch of placeholder code creating a window — delete all of that and replace it with this:</p><pre data-language="swift"><code><span class="hljs-comment">// StatusMenuApp/AppDelegate.swift</span>

<span class="hljs-meta">@NSApplicationMain</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">NSApplicationDelegate</span> </span>{
    
    <span class="hljs-keyword">var</span> statusItem : <span class="hljs-type">NSStatusItem!</span>
    <span class="hljs-keyword">var</span> popover : <span class="hljs-type">NSPopover!</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applicationDidFinishLaunching</span><span class="hljs-params">(<span class="hljs-number">_</span> aNotification: Notification)</span></span> {

        <span class="hljs-comment">// Create the status item</span>
        statusItem = <span class="hljs-type">NSStatusBar</span>.system.statusItem(withLength: <span class="hljs-type">NSStatusItem</span>.variableLength)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> statusButton = statusItem?.button {
            statusButton.image = <span class="hljs-type">NSImage</span>(systemSymbolName: <span class="hljs-string">"tornado"</span>, accessibilityDescription: <span class="hljs-literal">nil</span>)
            statusButton.action = #selector(togglePopover(sender:))
            statusButton.target = <span class="hljs-keyword">self</span>
        }
        
        <span class="hljs-comment">// Create the popover</span>
        popover = <span class="hljs-type">NSPopover</span>()
        <span class="hljs-keyword">let</span> content = <span class="hljs-type">NSHostingController</span>(rootView: <span class="hljs-type">ContentView</span>())
        popover.contentViewController = content
        popover.contentSize = content.view.intrinsicContentSize
        popover.behavior = .transient
        popover.animates = <span class="hljs-literal">false</span>
    }
}
</code></pre><p>This code does two things:</p><ol><li>Creates a new <code>NSStatusItem</code> in the system status bar. Status items can have either a drop-down menu or a button; we’ll create a button with a tornado icon that displays a popover when clicked.</li><li>Creates an <code>NSPopover</code> with a SwiftUI view. We set the popover’s <code>behavior</code> to <code>.transient</code>, which means the popover closes if you click anywhere outside of it, and <code>animates</code> to <em>false</em> because I find the default open/close animations to be frustratingly slow. We also set the popover’s <code>contentSize</code> here using the SwiftUI view’s <code>intrinsicContentSize</code> — ideally SwiftUI would size the popover for us, but in my testing it seems we need to set the <code>contentSize</code> before we try to show the popover or its position will be wrong.</li></ol><p>Now all we need is to add <code>togglePopover(sender:)</code> to <strong>AppDelegate.swift</strong>, which either shows the popover relative to the status item, or closes the popover if it’s already showing.</p><pre data-language="swift"><code><span class="hljs-comment">// StatusMenuApp/AppDelegate.swift</span>

<span class="hljs-meta">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">togglePopover</span><span class="hljs-params">(sender: <span class="hljs-keyword">Any</span>?)</span></span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> statusButton = statusItem.button <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    
    <span class="hljs-keyword">if</span> popover.isShown {
        popover.performClose(sender)
    } <span class="hljs-keyword">else</span> {
        popover.show(relativeTo: statusButton.bounds,
                     of: statusButton,
                     preferredEdge: <span class="hljs-type">NSRectEdge</span>.maxY)
    }
}
</code></pre><p>At this point, you should be able to <strong>Run</strong> your status menu target. The little tornado icon should appear in the menu bar, and clicking it should show a popover. You’re a Mac developer now!</p><h2>Embed the Status Menu App in the Catalyst App</h2><p>Now let’s switch back to our main target, which is our Mac Catalyst app. We need to bundle our status menu app inside our Catalyst app, which first means adding the status menu target as a dependency of our Catalyst app.</p><p>Go to the Catalyst target’s <strong>Build Phases</strong> tab and open <strong>Dependencies</strong>. Click the plus button and choose the status menu app’s target. Then click the <strong>Platforms</strong> drop-down next to the added dependency and select <strong>macOS</strong> — this tells Xcode to only build the status menu for the Catalyst version of our app.</p><figure><img src="https://blog.overdesigned.net/images/menu-dependencies.png" srcset="/images/menu-dependencies.png 2x" alt="Screenshot of our main target’s Build Phases > Dependencies in Xcode" /></figure><p>Now to actually embed the status menu app. Click the plus button at the top of the <strong>Build Phases</strong> tab and select <strong>New Copy Files Phase</strong>. Expand the new “Copy Phase”, rename it to “Copy Status Menu”, and set its <strong>Destination</strong> to <code>Wrapper</code> and <strong>Subpath</strong> to <code>Contents/Library/LoginItems</code>. Click the plus button to add your status menu app’s product (it should have a name like <code>Your_Status_Menu_Target.app</code>); then in the <strong>Platforms</strong> drop-down, select <strong>macOS</strong>.</p><figure><img src="https://blog.overdesigned.net/images/menu-copy-phase.png" srcset="/images/menu-copy-phase.png 2x" alt="Screenshot of our Copy Files build phase in Xcode" /></figure><p>Now <strong>Run</strong> your Catalyst app. It should compile and run, but you won’t see the status menu because we haven’t done anything to launch it. The final step is to implement the method for enabling the status menu.</p><h2>Set the Status Menu App as a Login Item</h2><p>Status menu apps are usually run as <strong>login items</strong>, which means they are launched automatically when a Mac is restarted. Because our Catalyst app is sandboxed, the only way to set a login item is to call this method from the <code>ServiceManagement</code> framework:</p><pre data-language="c"><code><span class="hljs-function">Boolean <span class="hljs-title">SMLoginItemSetEnabled</span><span class="hljs-params">(CFStringRef identifier, Boolean enabled)</span></span>;
</code></pre><p>That’s a global C function and it’s marked as <code>unavailable</code> in iOS and Catalyst. Thankfully, this is easy to work around: just add the function definition to your Catalyst app’s <strong>bridging header</strong> (<a href="https://mycodetips.com/ios/manually-adding-swift-bridging-header-1290.html">add one</a> if you don’t have one).</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/CatalystApp-Bridging-Header.h</span>

#ifndef <span class="hljs-type">CatalystApp</span>-<span class="hljs-type">Bridging</span>-<span class="hljs-type">Header_h</span>
#define <span class="hljs-type">CatalystApp</span>-<span class="hljs-type">Bridging</span>-<span class="hljs-type">Header_h</span>
#include &lt;<span class="hljs-type">CoreFoundation</span>/<span class="hljs-type">CoreFoundation</span>.h&gt;

<span class="hljs-comment">// other Objective-C imports here...</span>

<span class="hljs-type">Boolean</span>
<span class="hljs-type">SMLoginItemSetEnabled</span>(<span class="hljs-type">CFStringRef</span> identifier, <span class="hljs-type">Boolean</span> enabled);

#endif
</code></pre><p>Sticking that in a header file will convince the compiler that calling <code>SMLoginItemSetEnabled(_:_:)</code> is okay. To use it, just import <code>ServiceManagement</code> and pass in your status menu app’s <strong>bundle identifier</strong> as <code>CFString</code>. The function will return <code>true</code> if the login item is successfully enabled/disabled, or return <code>false</code> if it couldn’t find an embedded app with the given bundle ID.</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/StatusMenuHelper.swift</span>

<span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> ServiceManagement

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusMenuHelper</span>: <span class="hljs-title">ObservableObject</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStatusMenuEnabled</span><span class="hljs-params">(<span class="hljs-number">_</span> isEnabled: Bool)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">let</span> bundleId = <span class="hljs-string">"status_menu_app_bundle_id"</span> <span class="hljs-keyword">as</span> <span class="hljs-type">CFString</span>
        <span class="hljs-keyword">return</span> <span class="hljs-type">SMLoginItemSetEnabled</span>(bundleId, isEnabled)
    }
    
    @<span class="hljs-type">AppStorage</span>(<span class="hljs-string">"status-menu-is-enabled"</span>)
    <span class="hljs-keyword">var</span> isEnabled = <span class="hljs-literal">false</span> {
        <span class="hljs-keyword">didSet</span> {
            <span class="hljs-keyword">if</span> setStatusMenuEnabled(isEnabled) {
                <span class="hljs-comment">// success!</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// SMLoginItemSetEnabled failed</span>
                isEnabled = <span class="hljs-literal">false</span>
            }
        }
    }
}
</code></pre><p>For convenience, I also created an <code>isEnabled</code> property using AppStorage so the enabled state is saved to UserDefaults. Now all that’s left to do is bind <code>isEnabled</code> to a Toggle in our Catalyst app’s interface:</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/CatalystAppView.swift</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CatalystAppView</span>: <span class="hljs-title">View</span> </span>{
    
    #<span class="hljs-keyword">if</span> targetEnvironment(macCatalyst)
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> statusMenuHelper = <span class="hljs-type">StatusMenuHelper</span>()
    #endif
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            #<span class="hljs-keyword">if</span> targetEnvironment(macCatalyst)
            <span class="hljs-type">Toggle</span>(<span class="hljs-string">"Enable Status Menu"</span>, isOn: $statusMenuHelper.isEnabled)
            #endif
            
            ...
        }
    }
}
</code></pre><p>And that’s it! Flipping that toggle <em>on</em> should show the status menu, and if you restart your computer the status menu should automatically relaunch. The full sample project for this post is available on <a href="https://github.com/aoverholtzer/CatalystStatusMenu">GitHub</a>, and check out <a href="https://overdesigned.net/cheatsheet/">Cheatsheet</a> to see a status menu working in a production app. Thanks for reading!</p><figure><img src="https://blog.overdesigned.net/images/status-menu-example.jpg" alt="Screenshot of my sample app and status menu" /></figure>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2020-09-23-swiftui-availability</guid><title>SwiftUI View Modifiers and if #available</title><description>Doing availability checks with SwiftUI's declarative syntax can be a little messy. Here's a custom view modifier that can help.</description><link>https://blog.overdesigned.net/posts/2020-09-23-swiftui-availability</link><pubDate>Wed, 23 Sep 2020 09:41:00 -0700</pubDate><content:encoded><![CDATA[<h1>SwiftUI View Modifiers and <code>if #available</code></h1><h2>tl;dr</h2><p>Here is a view modifier that lets you run arbitrary code before returning a modified view:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span>&lt;T: View&gt;<span class="hljs-params">(@ViewBuilder <span class="hljs-number">_</span> modifier: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> modifier(<span class="hljs-keyword">self</span>)
    }
}
</code></pre><p>What is it good for? Combining view modifiers with platform availability checks!</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello, world!"</span>)
        .modify {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                $<span class="hljs-number">0</span>.textCase(.uppercase)
            } <span class="hljs-keyword">else</span> {
                $<span class="hljs-number">0</span> <span class="hljs-comment">// watchOS 6 fallback</span>
            }
        }
    }
}
</code></pre><p>You can really go nuts with it if you're so inclined…</p><pre data-language="swift"><code><span class="hljs-type">Picker</span>(<span class="hljs-string">"Pick One"</span>, selection: $option) {
    ...
}
.modify {
    #<span class="hljs-keyword">if</span> os(watchOS)
        <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
            $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">InlinePickerStyle</span>())
        } <span class="hljs-keyword">else</span> { 
            $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">DefaultPickerStyle</span>())
        }
    #elseif targetEnvironment(macCatalyst)
        $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">DefaultPickerStyle</span>())
    #<span class="hljs-keyword">else</span> 
        $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">WheelPickerStyle</span>())
    #endif
}
</code></pre><h2>Why do we need this?</h2><p>iOS 14, watchOS 7, and macOS 11 have brought major updates to SwiftUI. If you have an app that supports older OS versions, then you probably very familiar with <code>#available</code>:</p><pre data-language="swift"><code><span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
    <span class="hljs-comment">// the new hotness</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// old and busted</span>
}
</code></pre><p>Unfortunately, doing availability checks with SwiftUI's declarative syntax can be a little messy. In case you haven't tried it, let's look at an example for watchOS.</p><p>Here's a very basic watchOS view, written for watchOS 6:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">ToolbarView</span>()
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
    }
}
</code></pre><p>SwiftUI 2 added support for toolbars on all platforms, which we should use instead of shoving <code>ToolbarView()</code> into the top of the <code>List</code>. Here's what that looks like <em>without</em> support for watchOS 6:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
        .toolbar { <span class="hljs-comment">// error: toolbar requries watchOS 7</span>
            <span class="hljs-type">ToolbarView</span>()
        }
    }
}
</code></pre><p>To also support watchOS 6, it would be nice if we could wrap the differences between these code blocks in <code>if #available</code> like so:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                <span class="hljs-comment">// use .toolbar() below</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">ToolbarView</span>()
            }
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
        <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) { <span class="hljs-comment">// error</span>
            .toolbar {
                <span class="hljs-type">ToolbarView</span>()
            }
        }
    }
}
</code></pre><p>Alas, this code won't compile. The first use of <code>if #available</code> is good but the second — attempting to wrap the <code>.toolbar()</code> view modifier — does not work. We would need to wrap an <code>if-else</code> around the <em>entire</em> <code>List</code>, which means either duplicating a lot of code or refactoring our view. This is a simple example, but I'm sure you can imagine how ugly this can get for more complex views.</p><p>Why isn't there a better way?!</p><h2>Inspiration: Conditional view modifier</h2><p>You may have seen <a href="https://fivestars.blog/swiftui/conditional-modifiers.html">Federico Zanetello's Conditional View Modifier</a>, which takes a conditional and a closure as input:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ViewBuilder</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> `<span class="hljs-title">if</span>`&lt;Transform: View&gt;<span class="hljs-params">(<span class="hljs-number">_</span> condition: Bool, 
                                 transform: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">Transform</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">if</span> condition {
            transform(<span class="hljs-keyword">self</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>
        }
    }
}
</code></pre><p>This lets us <em>optionally</em> apply a view modifier, which is great for view modifiers that don't take any input, e.g.:</p><pre data-language="swift"><code><span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
.<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">5</span>) { 
    $<span class="hljs-number">0</span>.hidden() 
}
</code></pre><p>Unfortunately, as Federico explains, this trick won't work for availability checks:</p><blockquote>
<ul>
<li>Swift’s #available and @available cannot be passed as arguments in our if modifier</li>
<li>we can’t guarantee the compiler that our transform function would be applied only on iOS 14/13.4 and later</li>
</ul>
<p>If you find a way, I would love to know!</p>
</blockquote><p>Well Federico, I think I found a way.</p><h2>Closure view modifier</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span>&lt;T: View&gt;<span class="hljs-params">(@ViewBuilder <span class="hljs-number">_</span> modifier: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> modifier(<span class="hljs-keyword">self</span>)
    }
}
</code></pre><p>My solution omits the conditional and applies <code>@ViewBuilder</code> to the closure, which will allow us to define our own <code>if-else</code> inside the closure:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                <span class="hljs-comment">// use .toolbar() below</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">ToolbarView</span>()
            }
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                        
                }
            }
        }
        .modify {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                $<span class="hljs-number">0</span>.toolbar {
                    <span class="hljs-type">ToolbarView</span>()
                }
            } <span class="hljs-keyword">else</span> {
                $<span class="hljs-number">0</span>
            }
        }
    }
}
</code></pre><p>It may not be pretty, but it works.</p><p>(If you do find a more elegant solution, please <a href="https://twitter.com/aoverholtzer">let me know</a>.)</p>]]></content:encoded></item></channel></rss>