<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>overdesigned blog</title><description>A blog by Adam Overholtzer</description><link>https://blog.overdesigned.net</link><language>en</language><lastBuildDate>Thu, 30 May 2024 10:34:02 -0700</lastBuildDate><pubDate>Thu, 30 May 2024 10:34:02 -0700</pubDate><ttl>250</ttl><atom:link href="https://blog.overdesigned.net/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2024-02-29-visionos-window-basics</guid><title>Shattered Glass: Customizing Windows in visionOS</title><description>Tips and tricks for working with windows and glass in visionOS.</description><link>https://blog.overdesigned.net/posts/2024-02-29-visionos-window-basics</link><pubDate>Thu, 29 Feb 2024 09:41:00 -0800</pubDate><content:encoded><![CDATA[<figure><img src="https://blog.overdesigned.net/images/clocks-vision-promo.jpg" alt="Screenshot of my Clocks app on Apple Vision Pro" /></figure><h1>Shattered Glass: Customizing Windows in visionOS</h1><p>Developing for visionOS, it may seem like your app is stuck in a flat pane of glass. But with the right SwiftUI modifiers ‚Äî and maybe a sneaky call to UIKit ‚Äî we can achieve some neat effects! Read on to learn few of the windowing tricks I learned making <strong><a href="https://overdesigned.net/clocks/">Clocks</a></strong> for Apple Vision Pro.</p><h2>Make a transparent window</h2><p>Let‚Äôs start with the thing we all want to do at one point or another: <strong>remove the glass background from our window</strong>. Like many things with SwiftUI, this is quite easy once you find the right modifier: just set <code>.windowStyle(.plain)</code> on your <code>WindowGroup</code>.</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">ContentView</span>()
        }
        .windowStyle(.plain)
    }
}
</code></pre><p>And voil√†, a transparent window!</p><figure><img src="https://blog.overdesigned.net/images/visionos-window-basics1.jpg" alt="Screenshot of a window with transparent background on visionOS." /></figure><p>Of course, this window may be quite hard for our users to move or resize (or even see!), so we should also learn how to‚Ä¶</p><h2>Add glass background to a view</h2><p>Again, adding a glass background is easy if you know the right incancation: <code>.glassBackgroundEffect()</code>. Those of you familiar with SwiftUI's <code>Material</code> backgrounds might have thought that was the answer, but no, visionOS is much to fancy for that.</p><p>Anyway, let's look at this modifier:</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">glassBackgroundEffect</span>&lt;S&gt;<span class="hljs-params">(
    <span class="hljs-keyword">in</span> shape: S,
    displayMode: GlassBackgroundDisplayMode = .always
)</span></span> -&gt; some <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">S</span> : <span class="hljs-type">InsettableShape</span>
</code></pre><p>It has two options: shape and display mode. Display mode controls the visibility of the glass background and you can pass one of <code>.always</code>, <code>.never</code>, or <code>.implicit</code>.</p><p>The <code>shape</code> parameter is more interesting: it <em>appears</em> to accept any <code>InsettableShape</code>, but in practice only a few work: <code>RoundedRectangle</code>, <code>Capsule</code>, and <code>Circle</code>. Any other shape will appear as a simple rectangle and will lack specular highlights around the edges. As the <a href="https://developer.apple.com/documentation/swiftui/view/glassbackgroundeffect(in:displaymode:">documentation</a>) says:</p><blockquote><p>Prefer a shape for the background that has rounded corners. An unsupported shape style resolves to a rectangle.</p></blockquote><p>Here is some sample code and a screenshot of how the different shapes look:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Capsule"</span>)
                .padding()
                .glassBackgroundEffect(<span class="hljs-keyword">in</span>: .capsule)
            
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Circle"</span>)
                .padding(<span class="hljs-number">50</span>)
                .glassBackgroundEffect(<span class="hljs-keyword">in</span>: .circle)
            
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Round Rect"</span>)
                .padding()
                .glassBackgroundEffect(<span class="hljs-keyword">in</span>: .rect(cornerRadius: <span class="hljs-number">11</span>))
            
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Rectangle"</span>)
                .padding()
                .glassBackgroundEffect(<span class="hljs-keyword">in</span>: .rect)
        }
        .font(.extraLargeTitle)
    }
}
</code></pre><figure style="margin-bottom: 1em;"><img src="https://blog.overdesigned.net/images/visionos-window-basics2.jpg" alt="Screenshot of a visionOS window with transparent background and four small subviews with glass backgrounds: Capsule, Circle, Round Rect, and Rectangle." /></figure><figure class="fixed" style="width:300px;"><img src="https://blog.overdesigned.net/images/visionos-window-basics2b.jpg" alt="Screenshot of a visionOS window with transparent background and four small subviews with glass backgrounds: Capsule, Circle, Round Rect, and Rectangle." /></figure><p>Notice the lack of specular highlights ‚Äî the light-catching edges of the glass panes ‚Äî on the sharp-cornered rectangle.</p><h3>Into the third dimension!</h3><p>Now that we have a transparent window and know how to create multiple glass-backed views inside of it, we can play around with some fun 3D effects and layouts.</p><p>Use <code>.offset(z:)</code> to stack and overlay your views in three dimensions. Or try playing around with <code>.rotation3DEffect(_:axis:anchor:)</code> to tilt and turn your views in 3D.</p><figure><img src="https://blog.overdesigned.net/images/visionos-window-basics3.jpg" alt="Screenshot of a visionOS window with multiple panels arranged in 3D." /></figure><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PanelView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">HStack</span>(spacing: <span class="hljs-number">20</span>) {
            
            <span class="hljs-type">ZStack</span>(alignment: .topLeading) {
                <span class="hljs-type">ListView</span>()
                    .glassBackgroundEffect()
                
                <span class="hljs-type">Button</span>(<span class="hljs-string">"Close"</span>, systemImage: <span class="hljs-string">"xmark"</span>, action: { })
                    .labelStyle(.iconOnly)
                    .glassBackgroundEffect(<span class="hljs-keyword">in</span>: .circle)
                    .offset(x: -<span class="hljs-number">20</span>, y: -<span class="hljs-number">10</span>)
                    .offset(z: <span class="hljs-number">10</span>)
            }
            .rotation3DEffect(.degrees(<span class="hljs-number">40</span>),
                              axis: .y,
                              anchor: .trailing)
            
            <span class="hljs-type">MainView</span>()
                .glassBackgroundEffect()
            
            <span class="hljs-type">VStack</span>(spacing: -<span class="hljs-number">20</span>) {
                <span class="hljs-type">DetailView</span>()
                    .glassBackgroundEffect()
                <span class="hljs-type">DetailView</span>(style: .light)
                    .glassBackgroundEffect()
                    .offset(z: <span class="hljs-number">45</span>)
                <span class="hljs-type">DetailView</span>(style: .dark)
                    .glassBackgroundEffect()
                    .offset(z: <span class="hljs-number">90</span>)
            }
            .rotation3DEffect(.degrees(-<span class="hljs-number">30</span>),
                              axis: .y,
                              anchor: .leading)
        }
    }
}
</code></pre><p>If you want to get really fancy, try combining these modifiers with animation and interactivity, like this flippy interaction from my <a href="https://overdesigned.net/clocks/">Clocks</a> app:</p><figure><iframe id="ytplayer" type="text/html" width="400" height="225" src="https://www.youtube.com/embed/3L0s9NX9UsA?autoplay=1&loop=1&controls=0&playsinline&playlist=3L0s9NX9UsA&rel=0" frameborder="0" alt="Video of a visionOS window flipping in 3D."></iframe></figure><h2>Set a window‚Äôs default and minimum size</h2><p>Setting a window's minimum size is straightforward: use <code>.frame(minWidth:minHeight:)</code> on your view. This also works for <code>maxWidth</code> and <code>maxHeight</code> if you want to specify a maximum size for a window.</p><p>Now you might think <code>.frame(idealWidth:idealHeight:)</code> would set a window's default size, but these parameters don't seem to do anything. Instead, use the new(ish) modifier <code>.defaultSize(width:height:)</code> on your <code>WindowGroup</code>.</p><p>If that's a little unclear, here's a full example:</p><pre data-language="swift"><code><span class="hljs-type">WindowGroup</span> {
    <span class="hljs-type">PanelView</span>()
        .frame(minWidth: <span class="hljs-number">540</span>, minHeight: <span class="hljs-number">320</span>)
}
.windowStyle(.plain)
.defaultSize(width: <span class="hljs-number">800</span>, height: <span class="hljs-number">600</span>)
</code></pre><h2>Resize a window</h2><p>Programmatically resizing a window ‚Äî at least as-of visionOS 1.1 ‚Äî can only be done with UIKit. Specifically, you need to have your window's <code>UIWindowScene</code> so you can call <code>requestGeometryUpdate</code> with a new size like so:</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> size = <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">1440</span>, height: <span class="hljs-number">900</span>)
windowScene.requestGeometryUpdate(.<span class="hljs-type">Vision</span>(size: size))
</code></pre><p>There are a few ways to get the current <code>UIWindowScene</code> in SwiftUI, but the most common ‚Äî looping through <code>UIApplication.shared.connectedScenes</code> to find the key window ‚Äî is risky on visionOS because window foregrounding and focus don't work like they do on other platforms.</p><p>Instead of doing that, I'll link to two better solutions:</p><ol><li>Create <code>AppDelegate</code> and <code>SceneDelegate</code> classes and use them to capture a reference to your <code>UIWindow</code>, as explained in this excellent <a href="https://stackoverflow.com/a/60359809">Stack Overflow answer</a> by Asperi.</li><li>Create a <code>UIViewRepresentable</code> that captures its parent <code>UIWindow</code> and passes it up the view hierarchy using a <code>PreferenceKey</code>. I'm using the <a href="https://github.com/divadretlaw/WindowSceneReader">WindowSceneReader</a> library by David Walter, which elegantly handles all this messiness for me.</li></ol><h2>Hide the standard window controls</h2><p>Add <code>.persistentSystemOverlays(.hidden)</code> to a view to hide the standard window controls, i.e., the close button and drag bar. They'll appear briefly when the window opens before disappearing; the controls reappear if the user ‚Äútaps‚Äù on the window, or you can control this programatically with a ternary operator, e.g.:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ControlHidingView</span>&lt;<span class="hljs-title">Content</span>: <span class="hljs-title">View</span>&gt;: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ViewBuilder</span> <span class="hljs-keyword">var</span> content: ()-&gt;<span class="hljs-type">Content</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> hideControls = <span class="hljs-literal">true</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        content()
            .onTapGesture {
                hideControls.toggle()
            }
            .persistentSystemOverlays(hideControls ? .hidden : .visible)
    }
}
</code></pre><p>This modifier also works for hiding the Home indicator on iOS.</p><p>--</p><p>That's it for now! If you have any questions/comments/corrections, feel free to reach out to <a href="https://iosdev.space/@adam">@adam@iosdev.space on Mastodon</a> or <a href="https://twitter.com/aoverholtzer">@aoverholtzer on Twitter</a>. And if this article has been helpful, please check out <a href="https://overdesigned.net/">my apps</a>. Thanks for reading!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2021-09-29-swiftui-animation-tricks</guid><title>SwiftUI Animation Lessons From Building ‚ÄúTime‚Äôs¬†Up!¬†Timer‚Äù</title><description>Here are a few of the SwiftUI animation tips and tricks I‚Äôve learned building my kid-friendly timer app Time‚Äôs Up! Timer.</description><link>https://blog.overdesigned.net/posts/2021-09-29-swiftui-animation-tricks</link><pubDate>Wed, 29 Sep 2021 09:41:00 -0700</pubDate><content:encoded><![CDATA[<figure><img src="https://blog.overdesigned.net/images/times-up-promo.jpg" alt="Screenshot of a Time‚Äôs Up! Timer" /></figure><h1>SwiftUI Animation Lessons From Building ‚ÄúTime‚Äôs¬†Up!¬†Timer‚Äù</h1><p>I recently launched <strong><a href="https://overdesigned.net/timesup/">Time‚Äôs¬†Up!¬†Timer</a></strong>, a kid-friendly timer app for iOS, macOS, and tvOS. It‚Äôs a SwiftUI app that makes heavy use of animations, so I thought I‚Äôd share a few of the SwiftUI animation tips and tricks I‚Äôve learned building it.</p><h2>Use <code>animation(_:value:)</code> instead of <code>animation(_:)</code></h2><p>Let‚Äôs start with the simplest lesson: always use <code>animation(_:value:)</code> for implicit animations. Unlike the simpler <code>animation(_:)</code> modifier, this also requires an <code>Equatable</code> value parameter; the animation will <em>only</em> be applied when that value changes. Without this, the animation may run when other properties change or during transitions.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-1.gif" alt="Animated GIF of a springy clock hand." /></figure><p>Here‚Äôs an excerpt from the code for my timer view, which draws a clock face and a hand. The hand moves with a bouncy spring animation when its <code>angle</code> changes ‚Äî and <em>only</em> when its <code>angle</code> changes ‚Äî thanks to <code>animation(_:value:)</code>.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TimerClockfaceView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Angle</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            makeFace()
        
            makeHand()
                .rotationEffect(angle)
                .animation(.interactiveSpring(), value: angle)
        }
    }
}
</code></pre><p>The value-less version of <code>animation(_:)</code> is deprecated as of iOS 15 / macOS 12, which means Apple agrees: always use <code>animation(_:value:)</code>.</p><h2>Always test device rotation</h2><p>Speaking of unwanted animation: SwiftUI views will animate to their new sizes when you rotate your iPhone or iPad, and this may produce some undesirable results. I recommend testing device rotation in the simulator with <strong>Debug &rarr; Slow Animations</strong> enabled so you can see exactly what‚Äôs happening and fix it.</p><h2>Respect your user‚Äôs Reduce Motion setting</h2><p>iOS has a <strong>Reduce Motion</strong> accessibility setting, which disables or simplifies most animations. Try it yourself by going to <strong>Settings &rarr; Accessibility &rarr; Motion &rarr; Reduce Motion.</strong> Third-party apps like ours should respect this setting too, and with SwiftUI it‚Äôs incredibly easy.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TimerClockfaceView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Angle</span>
    @<span class="hljs-type">Environment</span>(\.accessibilityReduceMotion) <span class="hljs-keyword">var</span> reduceMotion
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            makeFace()
            
            makeHand()
                .rotationEffect(angle)
                .animation(reduceMotion ? .<span class="hljs-keyword">none</span> : .interactiveSpring(),
                           value: angle)
        }
    }
}
</code></pre><p>We first read the user‚Äôs preference using the <code>\.accessibilityReduceMotion</code> environment value, then use a ternary operator in <code>animation(_:value:)</code> to set the animation to <code>.none</code> if <code>reduceMotion</code> is true.</p><h2>Use <code>withTransaction</code> to override implicit animations</h2><p>Here‚Äôs a snippet of code from my main view, which shows the timer, the remaining time as <code>Text</code>, and a <strong>Reset</strong> button that will reset the timer with a nice (slow) <code>.default</code> animation.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">Text</span>(timer.remainingTimeString)
                .font(.title)
            <span class="hljs-type">TimerClockfaceView</span>()
                .aspectRatio(<span class="hljs-number">1</span>, contentMode: .fit)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Reset"</span>) {
                withAnimation(.<span class="hljs-keyword">default</span>) {
                    timer.reset()
                }
            }
        }
    }
}
</code></pre><p>And here‚Äôs a capture of what happens when I tap <strong>Reset</strong>.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-2.gif"/></figure><p>It‚Äôs not working as expected ‚Äî the implicit spring animation on the clock hand hand is overriding the explicit <code>withAnimation</code> in our Reset function. How can we <em>override</em> the spring animation?</p><p>The solution is <code>withTransaction</code>, which is similar to <code>withAnimation</code> except it takes a <code>Transaction</code> object. A <code>Transaction</code> represents the <em>context</em> of the current state-processing update, including the animation that will be applied.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        ...
        <span class="hljs-type">Button</span>(<span class="hljs-string">"Reset"</span>) {
            <span class="hljs-keyword">var</span> transaction = <span class="hljs-type">Transaction</span>(animation: .<span class="hljs-keyword">default</span>)
            transaction.disablesAnimations = <span class="hljs-literal">true</span>
            withTransaction(transaction) {
                timer.reset()
            }
        }
    }
}
</code></pre><p>First we create a <code>Transaction</code> with the <code>.default</code> animation we want. Then we set the Transaction‚Äôs <code>disablesAnimations</code> property to true, which tells it to disable all <em>implicit</em> animations on the affected views. Finally, we call <code>withTransaction(_:_:)</code> like we would <code>withAnimation(_:_:)</code>, providing our transaction and a closure to execute.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-3.gif"/></figure><p>Looks good!</p><p>(Actually <code>Animation.default</code> is pretty lame and I don‚Äôt actually use it in my app, but you get the idea!)</p><h2>Use <code>transaction(_:)</code> to override explicit animations</h2><p>Now if you look closely at that last animation, you may notice something else that doesn‚Äôt look right: when we tap <strong>Reset</strong>, the time <code>Text</code> view changes size and that change is animated.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-4.gif"/></figure><p>Yuck. Let‚Äôs disable that animation using <code>transaction(_:)</code>, which is a View Modifier that lets us change or replace the <code>Transaction</code> being applied to the view when we called <code>withAnimation</code> or <code>withTransaction</code>. In this case, we want no animation for the <code>Text</code> so we set <code>transaction.animation</code> to <code>.none</code>.</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">TimesUpTimer</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    	<span class="hljs-type">Text</span>(timer.remainingTimeString)
    	    .transaction { transaction <span class="hljs-keyword">in</span>
    	        transaction.animation = .<span class="hljs-keyword">none</span>
    	    }
    	...
    }
}
</code></pre><p>Here‚Äôs the final result: the hand animates smoothly while the time snaps to its new value immediately.</p><figure class='fixed'><img src="https://blog.overdesigned.net/images/swiftui-animation-5.gif"/></figure><p>This is a very simple use of <code>transaction(_:)</code> but many things are possible: you could change to a different animation, add a delay, or change the current animation‚Äôs duration. It‚Äôs pretty cool.</p><p>One word of warning from the <a href="https://developer.apple.com/documentation/SwiftUI/Form/transaction%28_:%29">documentation</a>:</p><blockquote><p>Use this modifier on leaf views such as <code>Image</code> or <code>Button</code> rather than container views such as <code>VStack</code> or <code>HStack</code>. The transformation applies to all child views within this view; calling <code>transaction(_:)</code> on a container view can lead to unbounded scope of execution depending on the depth of the view hierarchy.</p></blockquote><h2>For animation-heavy Mac apps, consider Catalyst</h2><p><a href="https://overdesigned.net/timesup/">Time‚Äôs Up! Timer</a> is available for iOS, macOS, and tvOS, which required some platform-specific optimizations.</p><p>For tvOS, testing on real hardware is key because Apple TV boxes are relatively underpowered. I simplified a few views and animations to compensate.</p><p>The Mac app was more of a problem, in a way I didn‚Äôt expect: <strong>SwiftUI animations run very poorly on macOS 11</strong> (I have not done performance testing on macOS 12). I tried using <code>drawingGroup()</code> everywhere I could, but that wasn‚Äôt enough. My eventual solution was to abandon my ‚Äúnative‚Äù macOS app and switch to a Catalyst app, where animations run great! ü§∑üèª‚Äç‚ôÇÔ∏è</p><p>So my advice for animation-heavy SwiftUI Mac apps is to consider Catalyst. Catalyst may not be a good trade-off for many apps ‚Äî you can‚Äôt use <code>.toolbar</code> to make Mac toolbars, and you have no access to macOS-only APIs like <code>.commands</code> or <code>Settings</code> ‚Äî but for whatever reason, SwiftUI animations run much, <em>much</em> better in Catalyst apps.</p><h2>Learn more</h2><p>For an amazing, in-depth look at animation in SwiftUI, including <code>GeometryEffect</code> and the fancy new <code>TimelineView</code>, I highly recommend SwiftUI Lab‚Äôs <strike>three</strike><em>five</em> part series:</p><ol><li><a href="https://swiftui-lab.com/swiftui-animations-part1/">Advanced SwiftUI Animations ‚Äì Part 1: Paths</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part2/">Advanced SwiftUI Animations ‚Äì Part 2: GeometryEffect</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part3/">Advanced SwiftUI Animations ‚Äì Part 3: AnimatableModifier</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part4/">Advanced SwiftUI Animations ‚Äî Part 4: TimelineView</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/">Advanced SwiftUI Animations ‚Äì Part 5: Canvas</a></li></ol><p>Wondering how I made the ‚Äúshake‚Äù animation that‚Äôs used when a timer ends? Check out <a href="https://www.objc.io/blog/2019/10/01/swiftui-shake-animation/">SwiftUI: Shake Animation</a> from the objc.io blog.</p><p>Still confused by <code>Transaction</code>? Check out <a href="https://swiftwithmajid.com/2020/10/07/transactions-in-swiftui/">Transactions in SwiftUI</a> by Majid Jabrayilov.</p><p>If you have any questions/comments/corrections, feel free to reach out to <a href="https://twitter.com/aoverholtzer">@aoverholtzer on Twitter</a>. And if this article has been helpful, please check out <strong><a href="https://overdesigned.net/timesup/">Time‚Äôs Up! Timer</a></strong>. Thanks for reading!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2021-08-26-catalyst-status-menu</guid><title>Standalone Status Menu in a Mac Catalyst App</title><description>How to create a standalone ‚Äústatus menu‚Äù app and embed it in your Mac Catalyst app.</description><link>https://blog.overdesigned.net/posts/2021-08-26-catalyst-status-menu</link><pubDate>Thu, 26 Aug 2021 09:41:00 -0700</pubDate><content:encoded><![CDATA[<h1>Standalone Status Menu in a Mac Catalyst App</h1><figure><img src="https://blog.overdesigned.net/images/cheatsheet-menu.jpg" srcset="/images/cheatsheet-menu.jpg 2x" alt="Screenshot of Cheatsheet‚Äôs status menu" /></figure><p>I make a somewhat successful app called <strong><a href="https://itunes.apple.com/app/id1468213484">Cheatsheet</a></strong>, which is available for iOS, watchOS, and ‚Äî thanks to Catalyst ‚Äî macOS. Cheatsheet makes it easy to get to your notes from anywhere, which means widgets and custom keyboards on iOS and complications on watchOS. On macOS, Cheatsheet has a <em>status menu app</em>.</p><p>Look up at the righthand side of a Mac‚Äôs menu bar and you‚Äôll see a row of icons called <strong>status menus</strong>. Several status menus are provided by macOS, such as the Wi-Fi and Volume controls. Third-party apps can also create status menus to provide easy, always-available access to app features.</p><p>In this post, I will walk you through creating a <strong>status menu app</strong> ‚Äî a small Mac app that runs separately from its parent app ‚Äî and embedding it in a <strong>Mac Catalyst app</strong>. The parent app will have a checkbox that shows or hides the status menu, and clicking the status menu icon will show a popover.</p><figure><img src="https://blog.overdesigned.net/images/status-menu-example.jpg" alt="Screenshot of my sample app and status menu" /></figure><h2>Create the Status Menu App</h2><p>Let‚Äôs start with the fun part: building the status menu app. We‚Äôll build this new app with <strong>AppKit and SwiftUI</strong>, not iOS or Catalyst. Don‚Äôt fret if you‚Äôre new to AppKit ‚Äî this post has all the AppKit code you‚Äôll need, and then you can build the rest of your interface with SwiftUI.</p><p>To begin, select your project and add a new <strong>macOS App</strong> target.</p><figure><img src="https://blog.overdesigned.net/images/menu-mac-app.png" srcset="/images/menu-mac-app.png 2x" alt="Screenshot of a Xcode‚Äôs Add Target window" /></figure><p>Then in the ‚ÄúChoose options for your new target‚Äù screen, select <strong>Interface: SwiftUI</strong> and <strong>Life Cycle: AppKit App Delegate</strong>. We need the AppDelegate so we can create a windowless app, which is <em>technically</em> possible with the SwiftUI life cycle but it‚Äôs a bit of a <a href="https://github.com/zaferarican/menubarpopoverswiftui2">hack</a> and still requires an app delegate.</p><figure><img src="https://blog.overdesigned.net/images/menu-life-cycle.png" srcset="/images/menu-life-cycle.png 2x" alt="Screenshot of a Xcode‚Äôs Choose options for your new target window" /></figure><p>Enter a <strong>Product Name</strong> and click <strong>Finish</strong>.</p><p>Now select your new target and switch to its <strong>Info</strong> tab. Add a new property: <strong>Application is agent (UIElement)</strong>. Set its value to <strong>YES</strong>. This cryptically-named property tells macOS to run your app as an ‚Äúagent‚Äù, which means it won‚Äôt appear in the Dock or the Force Quit window.</p><figure><img src="https://blog.overdesigned.net/images/menu-uielement.png" srcset="/images/menu-uielement.png 2x" alt="Screenshot of the Info tab of our new target in Xcode" /></figure><p>With that out of the way, we‚Äôre ready to code! In the project navigator, open your new target‚Äôs <strong>AppDelegate.swift</strong> and look for <code>applicationDidFinishLaunching</code>. It will contain a bunch of placeholder code creating a window ‚Äî delete all of that and replace it with this:</p><pre data-language="swift"><code><span class="hljs-comment">// StatusMenuApp/AppDelegate.swift</span>

<span class="hljs-meta">@NSApplicationMain</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">NSApplicationDelegate</span> </span>{
    
    <span class="hljs-keyword">var</span> statusItem : <span class="hljs-type">NSStatusItem!</span>
    <span class="hljs-keyword">var</span> popover : <span class="hljs-type">NSPopover!</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applicationDidFinishLaunching</span><span class="hljs-params">(<span class="hljs-number">_</span> aNotification: Notification)</span></span> {

        <span class="hljs-comment">// Create the status item</span>
        statusItem = <span class="hljs-type">NSStatusBar</span>.system.statusItem(withLength: <span class="hljs-type">NSStatusItem</span>.variableLength)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> statusButton = statusItem?.button {
            statusButton.image = <span class="hljs-type">NSImage</span>(systemSymbolName: <span class="hljs-string">"tornado"</span>, accessibilityDescription: <span class="hljs-literal">nil</span>)
            statusButton.action = #selector(togglePopover(sender:))
            statusButton.target = <span class="hljs-keyword">self</span>
        }
        
        <span class="hljs-comment">// Create the popover</span>
        popover = <span class="hljs-type">NSPopover</span>()
        <span class="hljs-keyword">let</span> content = <span class="hljs-type">NSHostingController</span>(rootView: <span class="hljs-type">ContentView</span>())
        popover.contentViewController = content
        popover.contentSize = content.view.intrinsicContentSize
        popover.behavior = .transient
        popover.animates = <span class="hljs-literal">false</span>
    }
}
</code></pre><p>This code does two things:</p><ol><li>Creates a new <code>NSStatusItem</code> in the system status bar. Status items can have either a drop-down menu or a button; we‚Äôll create a button with a tornado icon that displays a popover when clicked.</li><li>Creates an <code>NSPopover</code> with a SwiftUI view. We set the popover‚Äôs <code>behavior</code> to <code>.transient</code>, which means the popover closes if you click anywhere outside of it, and <code>animates</code> to <em>false</em> because I find the default open/close animations to be frustratingly slow. We also set the popover‚Äôs <code>contentSize</code> here using the SwiftUI view‚Äôs <code>intrinsicContentSize</code> ‚Äî ideally SwiftUI would size the popover for us, but in my testing it seems we need to set the <code>contentSize</code> before we try to show the popover or its position will be wrong.</li></ol><p>Now all we need is to add <code>togglePopover(sender:)</code> to <strong>AppDelegate.swift</strong>, which either shows the popover relative to the status item, or closes the popover if it‚Äôs already showing.</p><pre data-language="swift"><code><span class="hljs-comment">// StatusMenuApp/AppDelegate.swift</span>

<span class="hljs-meta">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">togglePopover</span><span class="hljs-params">(sender: <span class="hljs-keyword">Any</span>?)</span></span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> statusButton = statusItem.button <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    
    <span class="hljs-keyword">if</span> popover.isShown {
        popover.performClose(sender)
    } <span class="hljs-keyword">else</span> {
        popover.show(relativeTo: statusButton.bounds,
                     of: statusButton,
                     preferredEdge: <span class="hljs-type">NSRectEdge</span>.maxY)
    }
}
</code></pre><p>At this point, you should be able to <strong>Run</strong> your status menu target. The little tornado icon should appear in the menu bar, and clicking it should show a popover. You‚Äôre a Mac developer now!</p><h2>Embed the Status Menu App in the Catalyst App</h2><p>Now let‚Äôs switch back to our main target, which is our Mac Catalyst app. We need to bundle our status menu app inside our Catalyst app, which first means adding the status menu target as a dependency of our Catalyst app.</p><p>Go to the Catalyst target‚Äôs <strong>Build Phases</strong> tab and open <strong>Dependencies</strong>. Click the plus button and choose the status menu app‚Äôs target. Then click the <strong>Platforms</strong> drop-down next to the added dependency and select <strong>macOS</strong> ‚Äî this tells Xcode to only build the status menu for the Catalyst version of our app.</p><figure><img src="https://blog.overdesigned.net/images/menu-dependencies.png" srcset="/images/menu-dependencies.png 2x" alt="Screenshot of our main target‚Äôs Build Phases > Dependencies in Xcode" /></figure><p>Now to actually embed the status menu app. Click the plus button at the top of the <strong>Build Phases</strong> tab and select <strong>New Copy Files Phase</strong>. Expand the new ‚ÄúCopy Phase‚Äù, rename it to ‚ÄúCopy Status Menu‚Äù, and set its <strong>Destination</strong> to <code>Wrapper</code> and <strong>Subpath</strong> to <code>Contents/Library/LoginItems</code>. Click the plus button to add your status menu app‚Äôs product (it should have a name like <code>Your_Status_Menu_Target.app</code>); then in the <strong>Platforms</strong> drop-down, select <strong>macOS</strong>.</p><figure><img src="https://blog.overdesigned.net/images/menu-copy-phase.png" srcset="/images/menu-copy-phase.png 2x" alt="Screenshot of our Copy Files build phase in Xcode" /></figure><p>Now <strong>Run</strong> your Catalyst app. It should compile and run, but you won‚Äôt see the status menu because we haven‚Äôt done anything to launch it. The final step is to implement the method for enabling the status menu.</p><h2>Set the Status Menu App as a Login Item</h2><p>Status menu apps are usually run as <strong>login items</strong>, which means they are launched automatically when a Mac is restarted. Because our Catalyst app is sandboxed, the only way to set a login item is to call this method from the <code>ServiceManagement</code> framework:</p><pre data-language="c"><code><span class="hljs-function">Boolean <span class="hljs-title">SMLoginItemSetEnabled</span><span class="hljs-params">(CFStringRef identifier, Boolean enabled)</span></span>;
</code></pre><p>That‚Äôs a global C function and it‚Äôs marked as <code>unavailable</code> in iOS and Catalyst. Thankfully, this is easy to work around: just add the function definition to your Catalyst app‚Äôs <strong>bridging header</strong> (<a href="https://mycodetips.com/ios/manually-adding-swift-bridging-header-1290.html">add one</a> if you don‚Äôt have one).</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/CatalystApp-Bridging-Header.h</span>

#ifndef <span class="hljs-type">CatalystApp</span>-<span class="hljs-type">Bridging</span>-<span class="hljs-type">Header_h</span>
#define <span class="hljs-type">CatalystApp</span>-<span class="hljs-type">Bridging</span>-<span class="hljs-type">Header_h</span>
#include &lt;<span class="hljs-type">CoreFoundation</span>/<span class="hljs-type">CoreFoundation</span>.h&gt;

<span class="hljs-comment">// other Objective-C imports here...</span>

<span class="hljs-type">Boolean</span>
<span class="hljs-type">SMLoginItemSetEnabled</span>(<span class="hljs-type">CFStringRef</span> identifier, <span class="hljs-type">Boolean</span> enabled);

#endif
</code></pre><p>Sticking that in a header file will convince the compiler that calling <code>SMLoginItemSetEnabled(_:_:)</code> is okay. To use it, just import <code>ServiceManagement</code> and pass in your status menu app‚Äôs <strong>bundle identifier</strong> as <code>CFString</code>. The function will return <code>true</code> if the login item is successfully enabled/disabled, or return <code>false</code> if it couldn‚Äôt find an embedded app with the given bundle ID.</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/StatusMenuHelper.swift</span>

<span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> ServiceManagement

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusMenuHelper</span>: <span class="hljs-title">ObservableObject</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStatusMenuEnabled</span><span class="hljs-params">(<span class="hljs-number">_</span> isEnabled: Bool)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">let</span> bundleId = <span class="hljs-string">"status_menu_app_bundle_id"</span> <span class="hljs-keyword">as</span> <span class="hljs-type">CFString</span>
        <span class="hljs-keyword">return</span> <span class="hljs-type">SMLoginItemSetEnabled</span>(bundleId, isEnabled)
    }
    
    @<span class="hljs-type">AppStorage</span>(<span class="hljs-string">"status-menu-is-enabled"</span>)
    <span class="hljs-keyword">var</span> isEnabled = <span class="hljs-literal">false</span> {
        <span class="hljs-keyword">didSet</span> {
            <span class="hljs-keyword">if</span> setStatusMenuEnabled(isEnabled) {
                <span class="hljs-comment">// success!</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// SMLoginItemSetEnabled failed</span>
                isEnabled = <span class="hljs-literal">false</span>
            }
        }
    }
}
</code></pre><p>For convenience, I also created an <code>isEnabled</code> property using AppStorage so the enabled state is saved to UserDefaults. Now all that‚Äôs left to do is bind <code>isEnabled</code> to a Toggle in our Catalyst app‚Äôs interface:</p><pre data-language="swift"><code><span class="hljs-comment">// CatalystApp/CatalystAppView.swift</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CatalystAppView</span>: <span class="hljs-title">View</span> </span>{
    
    #<span class="hljs-keyword">if</span> targetEnvironment(macCatalyst)
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> statusMenuHelper = <span class="hljs-type">StatusMenuHelper</span>()
    #endif
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            #<span class="hljs-keyword">if</span> targetEnvironment(macCatalyst)
            <span class="hljs-type">Toggle</span>(<span class="hljs-string">"Enable Status Menu"</span>, isOn: $statusMenuHelper.isEnabled)
            #endif
            
            ...
        }
    }
}
</code></pre><p>And that‚Äôs it! Flipping that toggle <em>on</em> should show the status menu, and if you restart your computer the status menu should automatically relaunch. The full sample project for this post is available on <a href="https://github.com/aoverholtzer/CatalystStatusMenu">GitHub</a>, and check out <a href="https://overdesigned.net/cheatsheet/">Cheatsheet</a> to see a status menu working in a production app. Thanks for reading!</p><figure><img src="https://blog.overdesigned.net/images/status-menu-example.jpg" alt="Screenshot of my sample app and status menu" /></figure>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.overdesigned.net/posts/2020-09-23-swiftui-availability</guid><title>SwiftUI View Modifiers and if #available</title><description>Doing availability checks with SwiftUI's declarative syntax can be a little messy. Here's a custom view modifier that can help.</description><link>https://blog.overdesigned.net/posts/2020-09-23-swiftui-availability</link><pubDate>Wed, 23 Sep 2020 09:41:00 -0700</pubDate><content:encoded><![CDATA[<h1>SwiftUI View Modifiers and <code>if #available</code></h1><h2>tl;dr</h2><p>Here is a view modifier that lets you run arbitrary code before returning a modified view:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span>&lt;T: View&gt;<span class="hljs-params">(@ViewBuilder <span class="hljs-number">_</span> modifier: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> modifier(<span class="hljs-keyword">self</span>)
    }
}
</code></pre><p>What is it good for? Combining view modifiers with platform availability checks!</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello, world!"</span>)
        .modify {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                $<span class="hljs-number">0</span>.textCase(.uppercase)
            } <span class="hljs-keyword">else</span> {
                $<span class="hljs-number">0</span> <span class="hljs-comment">// watchOS 6 fallback</span>
            }
        }
    }
}
</code></pre><p>You can really go nuts with it if you're so inclined‚Ä¶</p><pre data-language="swift"><code><span class="hljs-type">Picker</span>(<span class="hljs-string">"Pick One"</span>, selection: $option) {
    ...
}
.modify {
    #<span class="hljs-keyword">if</span> os(watchOS)
        <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
            $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">InlinePickerStyle</span>())
        } <span class="hljs-keyword">else</span> { 
            $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">DefaultPickerStyle</span>())
        }
    #elseif targetEnvironment(macCatalyst)
        $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">DefaultPickerStyle</span>())
    #<span class="hljs-keyword">else</span> 
        $<span class="hljs-number">0</span>.pickerStyle(<span class="hljs-type">WheelPickerStyle</span>())
    #endif
}
</code></pre><h2>Why do we need this?</h2><p>iOS 14, watchOS 7, and macOS 11 have brought major updates to SwiftUI. If you have an app that supports older OS versions, then you probably very familiar with <code>#available</code>:</p><pre data-language="swift"><code><span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
    <span class="hljs-comment">// the new hotness</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// old and busted</span>
}
</code></pre><p>Unfortunately, doing availability checks with SwiftUI's declarative syntax can be a little messy. In case you haven't tried it, let's look at an example for watchOS.</p><p>Here's a very basic watchOS view, written for watchOS 6:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">ToolbarView</span>()
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
    }
}
</code></pre><p>SwiftUI 2 added support for toolbars on all platforms, which we should use instead of shoving <code>ToolbarView()</code> into the top of the <code>List</code>. Here's what that looks like <em>without</em> support for watchOS 6:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
        .toolbar { <span class="hljs-comment">// error: toolbar requries watchOS 7</span>
            <span class="hljs-type">ToolbarView</span>()
        }
    }
}
</code></pre><p>To also support watchOS 6, it would be nice if we could wrap the differences between these code blocks in <code>if #available</code> like so:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                <span class="hljs-comment">// use .toolbar() below</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">ToolbarView</span>()
            }
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                }
            }
        }
        <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) { <span class="hljs-comment">// error</span>
            .toolbar {
                <span class="hljs-type">ToolbarView</span>()
            }
        }
    }
}
</code></pre><p>Alas, this code won't compile. The first use of <code>if #available</code> is good but the second ‚Äî attempting to wrap the <code>.toolbar()</code> view modifier ‚Äî does not work. We would need to wrap an <code>if-else</code> around the <em>entire</em> <code>List</code>, which means either duplicating a lot of code or refactoring our view. This is a simple example, but I'm sure you can imagine how ugly this can get for more complex views.</p><p>Why isn't there a better way?!</p><h2>Inspiration: Conditional view modifier</h2><p>You may have seen <a href="https://fivestars.blog/swiftui/conditional-modifiers.html">Federico Zanetello's Conditional View Modifier</a>, which takes a conditional and a closure as input:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ViewBuilder</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> `<span class="hljs-title">if</span>`&lt;Transform: View&gt;<span class="hljs-params">(<span class="hljs-number">_</span> condition: Bool, 
                                 transform: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">Transform</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">if</span> condition {
            transform(<span class="hljs-keyword">self</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>
        }
    }
}
</code></pre><p>This lets us <em>optionally</em> apply a view modifier, which is great for view modifiers that don't take any input, e.g.:</p><pre data-language="swift"><code><span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
.<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">5</span>) { 
    $<span class="hljs-number">0</span>.hidden() 
}
</code></pre><p>Unfortunately, as Federico explains, this trick won't work for availability checks:</p><blockquote>
<ul>
<li>Swift‚Äôs #available and @available cannot be passed as arguments in our if modifier</li>
<li>we can‚Äôt guarantee the compiler that our transform function would be applied only on iOS 14/13.4 and later</li>
</ul>
<p>If you find a way, I would love to know!</p>
</blockquote><p>Well Federico, I think I found a way.</p><h2>Closure view modifier</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span>&lt;T: View&gt;<span class="hljs-params">(@ViewBuilder <span class="hljs-number">_</span> modifier: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> modifier(<span class="hljs-keyword">self</span>)
    }
}
</code></pre><p>My solution omits the conditional and applies <code>@ViewBuilder</code> to the closure, which will allow us to define our own <code>if-else</code> inside the closure:</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                <span class="hljs-comment">// use .toolbar() below</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">ToolbarView</span>()
            }
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>) { i <span class="hljs-keyword">in</span>
                <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">DetailView</span>(index: i)) {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Button \(i)"</span>)
                        
                }
            }
        }
        .modify {
            <span class="hljs-keyword">if</span> #available(watchOS <span class="hljs-number">7</span>, *) {
                $<span class="hljs-number">0</span>.toolbar {
                    <span class="hljs-type">ToolbarView</span>()
                }
            } <span class="hljs-keyword">else</span> {
                $<span class="hljs-number">0</span>
            }
        }
    }
}
</code></pre><p>It may not be pretty, but it works.</p><p>(If you do find a more elegant solution, please <a href="https://twitter.com/aoverholtzer">let me know</a>.)</p>]]></content:encoded></item></channel></rss>